<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Play Local Video</title>
    <style>
      body {
        font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
        background-color: #f0f4f8;
        color: #2c3e50;
        line-height: 1.6;
        padding: 20px;
        max-width: 1200px;
        margin: 0 auto;
      }
      h1 {
        text-align: center;
        color: #3498db;
        margin-bottom: 30px;
      }
      #videoPlayer {
        width: 100%;
        max-width: 800px;
        height: auto;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        margin-bottom: 20px;
        display: block; /* Add this line */
        margin-left: auto; /* Add this line */
        margin-right: auto; /* Add this line */
      }
      button {
        background-color: #3498db;
        color: white;
        border: none;
        padding: 10px 20px;
        margin: 5px;
        border-radius: 5px;
        cursor: pointer;
        transition: background-color 0.3s ease;
      }
      button:hover {
        background-color: #2980b9;
      }
      button:disabled {
        background-color: #bdc3c7;
        cursor: not-allowed;
      }
      #dataTable {
        background-color: white;
        border-radius: 8px;
        box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
        padding: 20px;
        margin-top: 30px;
      }
      table {
        width: 100%;
        border-collapse: separate;
        border-spacing: 0;
      }
      th,
      td {
        padding: 12px;
        text-align: left;
        border-bottom: 1px solid #e0e0e0;
      }
      th {
        background-color: #f8f9fa;
        font-weight: 600;
        color: #34495e;
      }
      tr:last-child td {
        border-bottom: none;
      }
      tr:hover {
        background-color: #f5f7fa;
      }
      .remove-btn {
        color: #e74c3c;
        cursor: pointer;
        font-size: 1.2em;
      }
      .button-container {
        display: flex;
        justify-content: space-between;
        gap: 10px;
        margin-bottom: 20px;
      }
      button {
        flex: 1;
        min-width: 0;
        white-space: nowrap;
        overflow: hidden;
        text-overflow: ellipsis;
      }
      @media (max-width: 768px) {
        body {
          padding: 10px;
        }
        .button-container {
          flex-direction: row;
        }
        button {
          padding: 10px 5px;
          font-size: 14px;
        }
      }
    </style>
    <script type="module">
      import {
        html,
        render,
        useState,
        useEffect
      } from 'https://unpkg.com/htm@3.0.4/preact/standalone.module.js'

      const dbName = 'VideoPlayerDB'
      const storeName = 'fileHandles'
      const positionStoreName = 'playbackPositions'
      const lastPlayedStoreName = 'lastPlayedTimes'
      let db

      // Initialize IndexedDB
      const initDB = () => {
        return new Promise((resolve, reject) => {
          const dbPromise = indexedDB.open(dbName, 3)
          dbPromise.onupgradeneeded = function (event) {
            db = event.target.result
            if (!db.objectStoreNames.contains(storeName)) {
              db.createObjectStore(storeName)
            }
            if (!db.objectStoreNames.contains(positionStoreName)) {
              db.createObjectStore(positionStoreName)
            }
            if (!db.objectStoreNames.contains(lastPlayedStoreName)) {
              db.createObjectStore(lastPlayedStoreName)
            }
          }
          dbPromise.onsuccess = function (event) {
            db = event.target.result
            resolve(db)
          }
          dbPromise.onerror = reject
        })
      }

      // Helper functions
      const saveFileHandleToIndexedDB = async fileHandle => {
        const transaction = db.transaction([storeName], 'readwrite')
        const store = transaction.objectStore(storeName)
        const request = store.get('fileHandles')
        request.onsuccess = function (event) {
          let fileHandles = event.target.result || []
          fileHandles.push(fileHandle)
          store.put(fileHandles, 'fileHandles')
        }
      }

      const getPlaybackPosition = fileName => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([positionStoreName], 'readonly')
          const store = transaction.objectStore(positionStoreName)
          const request = store.get(fileName)
          request.onsuccess = function (event) {
            const result = event.target.result
            console.log(`Retrieving position for ${fileName}:`, result)
            resolve(result ? result.position : null)
          }
          request.onerror = reject
        })
      }

      const savePlaybackPosition = (fileName, position) => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([positionStoreName], 'readwrite')
          const store = transaction.objectStore(positionStoreName)
          const request = store.put({ position }, fileName)
          request.onsuccess = resolve
          request.onerror = reject
        })
      }

      const saveLastPlayedTime = (fileName, time) => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([lastPlayedStoreName], 'readwrite')
          const store = transaction.objectStore(lastPlayedStoreName)
          const request = store.put(time, fileName)
          request.onsuccess = resolve
          request.onerror = reject
        })
      }

      const getLastPlayedTime = fileName => {
        return new Promise((resolve, reject) => {
          const transaction = db.transaction([lastPlayedStoreName], 'readonly')
          const store = transaction.objectStore(lastPlayedStoreName)
          const request = store.get(fileName)
          request.onsuccess = function (event) {
            resolve(event.target.result || 0)
          }
          request.onerror = reject
        })
      }

      // ... (other helper functions like loadVideo, selectVideo, etc.)

      function App() {
        const [savedFileHandle, setSavedFileHandle] = useState(null)
        const [videoSrc, setVideoSrc] = useState('')
        const [fileHandles, setFileHandles] = useState([])
        const [isPlaying, setIsPlaying] = useState(false)
        const [playbackPositions, setPlaybackPositions] = useState({})
        const [lastPlayedTime, setLastPlayedTime] = useState({})

        const handleKeyDown = event => {
          if (event.code === 'Space' && event.target.tagName !== 'BUTTON') {
            event.preventDefault()
            togglePlayPause()
          } else if (event.code === 'ArrowRight') {
            if (event.ctrlKey) {
              event.preventDefault()
              playSecondMostRecentVideo()
            } else {
              event.preventDefault()
              skipForward()
            }
          } else if (event.code === 'ArrowLeft') {
            event.preventDefault()
            skipBackward()
          } else if (event.code === 'KeyF') {
            event.preventDefault()
            toggleFullscreen()
          }
        }

        const skipForward = () => {
          const videoPlayer = document.getElementById('videoPlayer')
          if (videoPlayer) {
            videoPlayer.currentTime = Math.min(
              videoPlayer.currentTime + 5,
              videoPlayer.duration
            )
          }
        }

        const skipBackward = () => {
          const videoPlayer = document.getElementById('videoPlayer')
          if (videoPlayer) {
            videoPlayer.currentTime = Math.max(videoPlayer.currentTime - 5, 0)
          }
        }

        useEffect(() => {
          initDB().then(() => {
            loadSavedFileHandle()
            displayIndexedDBData()
          })

          // Update global event listener for spacebar, right arrow, and left arrow
          document.addEventListener('keydown', handleKeyDown)

          // Clean up the event listener when the component unmounts
          return () => {
            document.removeEventListener('keydown', handleKeyDown)
          }
        }, [])

        const loadSavedFileHandle = async () => {
          const transaction = db.transaction([storeName], 'readonly')
          const store = transaction.objectStore(storeName)
          const request = store.get('fileHandles')
          request.onsuccess = async function (event) {
            if (event.target.result && event.target.result.length > 0) {
              const lastHandle =
                event.target.result[event.target.result.length - 1]
              setSavedFileHandle(lastHandle)
              await loadVideo(lastHandle)
            }
          }
        }

        const loadVideo = async fileHandle => {
          try {
            const file = await fileHandle.getFile()
            const fileURL = URL.createObjectURL(file)
            setVideoSrc(fileURL)
            // Load the saved playback position
            const position = await getPlaybackPosition(fileHandle.name)
            if (position) {
              document.getElementById('videoPlayer').currentTime = position
            }
          } catch (error) {
            console.error('Error loading video:', error)
            setSavedFileHandle(null)
          }
        }

        const selectVideo = async () => {
          try {
            const [fileHandle] = await window.showOpenFilePicker({
              types: [
                {
                  description: 'MP4 Video',
                  accept: { 'video/mp4': ['.mp4'] }
                }
              ]
            })
            setSavedFileHandle(fileHandle)
            saveFileHandleToIndexedDB(fileHandle)
            await loadVideo(fileHandle)
            displayIndexedDBData()
          } catch (error) {
            console.error('Error selecting video:', error)
          }
        }

        const playVideo = () => {
          const videoPlayer = document.getElementById('videoPlayer')
          videoPlayer.play()
          setIsPlaying(true)
        }

        const displayIndexedDBData = async () => {
          const transaction = db.transaction(
            [storeName, positionStoreName, lastPlayedStoreName],
            'readonly'
          )
          const fileStore = transaction.objectStore(storeName)
          const positionStore = transaction.objectStore(positionStoreName)
          const lastPlayedStore = transaction.objectStore(lastPlayedStoreName)

          const fileRequest = fileStore.get('fileHandles')
          const positionRequest = positionStore.getAll()
          const lastPlayedRequest = lastPlayedStore.getAll()

          Promise.all([
            new Promise(resolve => (fileRequest.onsuccess = resolve)),
            new Promise(resolve => (positionRequest.onsuccess = resolve)),
            new Promise(resolve => (lastPlayedRequest.onsuccess = resolve))
          ])
            .then(async () => {
              const fileHandles = fileRequest.result || []
              const positions = {}
              const lastPlayed = {}

              // Use Promise.all to wait for all getPlaybackPosition and getLastPlayedTime calls
              await Promise.all(
                fileHandles.map(async handle => {
                  positions[handle.name] = await getPlaybackPosition(
                    handle.name
                  )
                  lastPlayed[handle.name] = await getLastPlayedTime(handle.name)
                })
              )

              // Sort fileHandles based on last played time
              fileHandles.sort((a, b) => {
                const timeA = lastPlayed[a.name] || 0
                const timeB = lastPlayed[b.name] || 0
                return timeB - timeA
              })

              setFileHandles(fileHandles)
              setPlaybackPositions(positions)
              setLastPlayedTime(lastPlayed)

              // Load the most recently played video
              if (fileHandles.length > 0) {
                const lastPlayedHandle = fileHandles[0]
                setSavedFileHandle(lastPlayedHandle)
                await loadVideo(lastPlayedHandle)
              }
            })
            .catch(error => {
              console.error('Error displaying IndexedDB data:', error)
            })
        }

        const clearIndexedDBData = () => {
          const transaction = db.transaction(
            [storeName, positionStoreName],
            'readwrite'
          )
          const fileStore = transaction.objectStore(storeName)
          const positionStore = transaction.objectStore(positionStoreName)

          const fileRequest = fileStore.clear()
          const positionRequest = positionStore.clear()

          Promise.all([
            new Promise(resolve => (fileRequest.onsuccess = resolve)),
            new Promise(resolve => (positionRequest.onsuccess = resolve))
          ]).then(() => {
            setSavedFileHandle(null)
            setVideoSrc('')
            setFileHandles([])
            alert('IndexedDB data cleared')
          })
        }

        const removeEntry = async index => {
          const fileHandleToRemove = fileHandles[index]
          if (fileHandleToRemove) {
            const transaction = db.transaction(
              [storeName, positionStoreName],
              'readwrite'
            )
            const fileStore = transaction.objectStore(storeName)
            const positionStore = transaction.objectStore(positionStoreName)

            // Remove from fileHandles
            const fileRequest = fileStore.get('fileHandles')
            fileRequest.onsuccess = function (event) {
              let currentFileHandles = event.target.result || []
              currentFileHandles = currentFileHandles.filter(
                handle => handle.name !== fileHandleToRemove.name
              )
              fileStore.put(currentFileHandles, 'fileHandles')
            }

            // Remove from positionStore
            positionStore.delete(fileHandleToRemove.name)

            // Update state
            setFileHandles(prevHandles =>
              prevHandles.filter((_, i) => i !== index)
            )
            setPlaybackPositions(prev => {
              const newPositions = { ...prev }
              delete newPositions[fileHandleToRemove.name]
              return newPositions
            })
            setLastPlayedTime(prev => {
              const newTimes = { ...prev }
              delete newTimes[fileHandleToRemove.name]
              return newTimes
            })

            // If the removed entry was the current video, clear it
            if (
              savedFileHandle &&
              savedFileHandle.name === fileHandleToRemove.name
            ) {
              setSavedFileHandle(null)
              setVideoSrc('')
              setIsPlaying(false)
            }
          }
        }

        const playVideoFromHandle = async index => {
          const fileHandle = fileHandles[index]
          if (fileHandle) {
            const videoPlayer = document.getElementById('videoPlayer')

            if (
              savedFileHandle &&
              savedFileHandle.name === fileHandle.name &&
              isPlaying
            ) {
              // If the clicked video is already playing, pause it
              videoPlayer.pause()
              setIsPlaying(false)
            } else {
              // Load and play the new video
              setSavedFileHandle(fileHandle)
              await loadVideo(fileHandle)
              videoPlayer.play()
              setIsPlaying(true)
            }

            const currentTime = Date.now()
            // Update last played time in state and IndexedDB
            setLastPlayedTime(prev => ({
              ...prev,
              [fileHandle.name]: currentTime
            }))
            await saveLastPlayedTime(fileHandle.name, currentTime)

            // Re-sort the file handles
            setFileHandles(prevHandles =>
              [...prevHandles].sort(
                (a, b) => lastPlayedTime[b.name] - lastPlayedTime[a.name]
              )
            )
          }
        }

        const loadPlaybackPositions = async () => {
          const transaction = db.transaction([positionStoreName], 'readonly')
          const store = transaction.objectStore(positionStoreName)
          const request = store.getAll()
          request.onsuccess = function (event) {
            const positions = {}
            event.target.result.forEach(item => {
              positions[item.key] = item.position
            })
            setPlaybackPositions(positions)
          }
        }

        const updatePlaybackPosition = () => {
          const videoPlayer = document.getElementById('videoPlayer')
          if (savedFileHandle) {
            const currentTime = videoPlayer.currentTime
            savePlaybackPosition(savedFileHandle.name, currentTime)
            setPlaybackPositions(prev => ({
              ...prev,
              [savedFileHandle.name]: currentTime
            }))

            const now = Date.now()
            // Update last played time in state and IndexedDB
            setLastPlayedTime(prev => ({
              ...prev,
              [savedFileHandle.name]: now
            }))
            saveLastPlayedTime(savedFileHandle.name, now)

            // Re-sort the file handles
            setFileHandles(prevHandles =>
              [...prevHandles].sort(
                (a, b) => lastPlayedTime[b.name] - lastPlayedTime[a.name]
              )
            )
          }
        }

        const togglePlayPause = () => {
          const videoPlayer = document.getElementById('videoPlayer')
          if (videoPlayer) {
            if (videoPlayer.paused) {
              videoPlayer.play()
              setIsPlaying(true)
            } else {
              videoPlayer.pause()
              setIsPlaying(false)
            }
          }
        }

        // Add this new function to toggle fullscreen
        const toggleFullscreen = () => {
          const videoPlayer = document.getElementById('videoPlayer')
          if (!document.fullscreenElement) {
            if (videoPlayer.requestFullscreen) {
              videoPlayer.requestFullscreen()
            } else if (videoPlayer.mozRequestFullScreen) {
              // Firefox
              videoPlayer.mozRequestFullScreen()
            } else if (videoPlayer.webkitRequestFullscreen) {
              // Chrome, Safari and Opera
              videoPlayer.webkitRequestFullscreen()
            } else if (videoPlayer.msRequestFullscreen) {
              // IE/Edge
              videoPlayer.msRequestFullscreen()
            }
          } else {
            if (document.exitFullscreen) {
              document.exitFullscreen()
            } else if (document.mozCancelFullScreen) {
              // Firefox
              document.mozCancelFullScreen()
            } else if (document.webkitExitFullscreen) {
              // Chrome, Safari and Opera
              document.webkitExitFullscreen()
            } else if (document.msExitFullscreen) {
              // IE/Edge
              document.msExitFullscreen()
            }
          }
        }

        // Add this new function
        const playSecondMostRecentVideo = () => {
          console.log('playSecondMostRecentVideo')

          console.log('fileHandles', fileHandles)
          if (fileHandles.length >= 2) {
            console.log('fileHandles', fileHandles)
            const currentVideoIndex = fileHandles.findIndex(
              handle => handle.name === savedFileHandle.name
            )
            const secondMostRecentIndex = currentVideoIndex === 0 ? 1 : 0
            console.log('secondMostRecentIndex', secondMostRecentIndex)
            playVideoFromHandle(secondMostRecentIndex)
          }
        }

        return html`
          <h1>Play Local Video</h1>
          <video
            id="videoPlayer"
            controls
            src=${videoSrc}
            onTimeUpdate=${updatePlaybackPosition}
            onPlay=${() => setIsPlaying(true)}
            onPause=${() => setIsPlaying(false)}
          >
            Your browser does not support the video tag.
          </video>
          <div class="button-container">
            <button onClick=${selectVideo}>Select Video</button>
            <button
              onClick=${playVideo}
              disabled=${!savedFileHandle || isPlaying}
            >
              Play Video
            </button>
            <button onClick=${clearIndexedDBData}>Clear Data</button>
          </div>
          <div id="dataTable">
            ${fileHandles.length === 0
              ? html`<p>No data found in IndexedDB.</p>`
              : html`
                  <table>
                    <thead>
                      <tr>
                        <th>File Name</th>
                        <th>Last Position</th>
                        <th>X</th>
                      </tr>
                    </thead>
                    <tbody>
                      ${fileHandles.map(
                        (handle, index) => html`
                          <tr>
                            <td onClick=${() => playVideoFromHandle(index)}>
                              ${handle.name || 'N/A'}
                            </td>
                            <td>
                              ${playbackPositions[handle.name] !== undefined
                                ? `${Math.floor(
                                    playbackPositions[handle.name]
                                  )} seconds`
                                : 'N/A'}
                            </td>
                            <td>
                              <span
                                class="remove-btn"
                                onClick=${() => removeEntry(index)}
                              >
                                🗑️
                              </span>
                            </td>
                          </tr>
                        `
                      )}
                    </tbody>
                  </table>
                `}
          </div>
        `
      }

      render(html`<${App} />`, document.body)
    </script>
  </head>
  <body></body>
</html>
